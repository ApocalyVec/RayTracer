<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Ray Tracer</title>


<script id="vshader" type="x-shader/x-vertex">
   attribute vec3 aPosition;
   varying   vec3 vPosition;

   uniform float sceneNum;  // user input
   varying float fsceneNum;  // user input

   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;

       fsceneNum = sceneNum;
   }
</script>

<script id="fshader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec3 vPosition;

    varying float fsceneNum;

    struct Sphere {
        vec3 center;
        float radius;
        vec3 color;
    };

    struct TrianglePlane {
        vec3 v1;
        vec3 v2;
        vec3 v3;
        vec3 color;
    };

    struct Ray {
        vec3 origin;
        vec3 direction;
    };

    struct Light {
        vec3 position;
        float ambience;
        vec3 specular;
        vec3 diffuse;
    };

    struct RayTracerOutput {
        vec3 color;
    };

    const int sphereNum = 4;
    const int planeNum = 1;

    Sphere spheres[sphereNum];
    TrianglePlane tPlanes[planeNum];

    Ray rays[1];
    Light light[1];

    int bounceNum;
    float reflectDecay;

    void initialize() {

        if (fsceneNum == 1.0) {
            bounceNum = 2;
            reflectDecay = 0.5;

            float x = vPosition.x; // pixel positions x
            float y = vPosition.y; // pixel positions y
            float z = vPosition.z; // pixel positions z
            float focalLength = 1.5;
            vec3 color = vec3(0.0, 0.0, 0.0);

            // Create spheres
            spheres[0].center = vec3(-.1, .2, 0);
            spheres[0].radius = 0.2;
            spheres[0].color = vec3(1.0, 0.0, 0.0);

            // create a second sphere
            spheres[1].center = vec3(.3, .2, -.4);
            spheres[1].radius = 0.2;
            spheres[1].color = vec3(0.0, 1.0, 0.0);

            // create a third sphere
            //        spheres[2].center = vec3(0.9, 0.0, 0.8);
            //        spheres[2].radius = 0.2;
            //        spheres[2].color = vec3(0.0, 0.0, 1.0);

            // create plane
            tPlanes[0].v1 = vec3(2.0, .0, 2.0);
            tPlanes[0].v2 = vec3(-2.0, .0, 2.0);
            tPlanes[0].v3 = vec3(0.0, .0, -2.0);

            tPlanes[0].color = vec3(0.0, 0.0, 1.0);

            // Create ray
            rays[0].origin = vec3(.2, .3, focalLength);
            rays[0].direction = normalize(vec3(x, y, -focalLength));

            // Create Light source
            light[0].position = vec3(-2.0, 2.0, 2.0);
            light[0].ambience = 0.3;
        }
        else if (fsceneNum == 2.0) {
            bounceNum = 5;
            reflectDecay = 0.9;

            float x = vPosition.x; // pixel positions x
            float y = vPosition.y; // pixel positions y
            float z = vPosition.z; // pixel positions z
            float focalLength = 2.0;
            vec3 color = vec3(0.0, 0.0, 0.0);

            float spherePos = 0.4;
            float sphereRad = 0.3;

            // Create spheres
            spheres[0].center = vec3(-spherePos, -spherePos, 0.5);
            spheres[0].radius = sphereRad;
            spheres[0].color = vec3(1.0, 0.0, 0.0);

            // create a second sphere
            spheres[1].center = vec3(spherePos, spherePos, 0.5);
            spheres[1].radius = sphereRad;
            spheres[1].color = vec3(0.0, 1.0, 0.0);

            // create a third sphere
            spheres[2].center = vec3(-spherePos, spherePos, 0.5);
            spheres[2].radius = sphereRad;
            spheres[2].color = vec3(1.0, 1.0, 0.0);

            // the forth sphere
            spheres[3].center = vec3(spherePos, -spherePos, .5);
            spheres[3].radius = sphereRad;
            spheres[3].color = vec3(0.0, 0.0, 1.0);

            // Create ray
            rays[0].origin = vec3(.0, .0, focalLength);
            rays[0].direction = normalize(vec3(x, y, -focalLength));

            // Create Light source
            light[0].position = vec3(0.0, 0.0, 1.5);
            light[0].ambience = 0.3;
        }

    }

    const float veryBigNum = 1e23;
    const float verySmallNum = 1e-23;

    vec3 lightColor = vec3(1.0);

    float checkIntersectSphere(Sphere sphere, Ray ray) {
        vec3 sphereCenter = sphere.center;
        float radius = sphere.radius;
        vec3 cameraSource = ray.origin;
        vec3 cameraDirection = ray.direction;

        vec3 distanceFromCenter = (cameraSource - sphereCenter);
        float B = 2.0 * dot(cameraDirection, distanceFromCenter);
        float C = dot(distanceFromCenter, distanceFromCenter) - pow(radius, 2.0);
        float delta = pow(B, 2.0) - 4.0 * C;
        float t = 0.0;
        if (delta > 0.0) {
            float sqRoot = sqrt(delta);
            float t1 = (-B + sqRoot) / 2.0;
            float t2 = (-B - sqRoot) / 2.0;
            t = min(t1, t2);
        }
        if (delta == 0.0) {
            t = -B / 2.0;
        }

        return t;
    }

    vec3 newell(vec3 v1, vec3 v2, vec3 v3) {
        float n1, n2, n3;

        n1 = (v1[1] - v2[1]) * (v1[2] + v2[2]) +
        (v2[1] - v3[1]) * (v2[2] + v3[2]) +
        (v3[1] - v1[1]) * (v3[2] + v1[2]);

        n2 = (v1[2] - v2[2]) * (v1[0] + v2[0]) +
        (v2[2] - v3[2]) * (v2[0] + v3[0]) +
        (v3[2] - v1[2]) * (v3[0] + v1[0]);

        n3 = (v1[0] - v2[0]) * (v1[1] + v2[1]) +
        (v2[0] - v3[0]) * (v2[1] + v3[1]) +
        (v3[0] - v1[0]) * (v3[1] + v1[1]);

        vec3 normal = normalize(vec3(n1, n2, n3));
        return normal;
    }

    // adopted from
    // https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/ray-triangle-intersection-geometric-solution
    float checkIntersectTPlane(TrianglePlane tPlane, Ray ray) {
        vec3 v0 = tPlane.v1;
        vec3 v1 = tPlane.v2;
        vec3 v2 = tPlane.v3;

        vec3 orig = ray.origin;
        vec3 dir = ray.direction;

        // computer the pane's normal
        vec3 N = newell(v0, v1, v2);
        // check if the ray and the plane are parallel
        float NdotRayDirection = dot(N, dir);
        if(NdotRayDirection < verySmallNum) return veryBigNum;  // the ray and the plane does not intersect because they are parallel

        // compute d
        float d = dot(N, normalize(v1)); // distance from the origin to the plane
        //compute t
        float t = -(dot(N, orig) + d) / NdotRayDirection;

        //check if the triangle is behind the ray
        if (t < 0.0) return veryBigNum;  // the triangle is behind

        //compute the intersection point
        vec3 P = orig + t * dir;

        // inside-outside test
        vec3 C; // vec perpendicular to the triangle's plane

        //edge 0
        vec3 edge0 = v1 - v0;
        vec3 vp0 = P - v0;
        C = edge0 * vp0;
        if (dot(N, C) < 0.0) return veryBigNum;

        //edge 1
        vec3 edge1 = v2 - v1;
        vec3 vp1 = P - v1;
        C = edge1 * vp1;
        if(dot(N, C) < 0.0) return veryBigNum;

        //edge 2
        vec3 edge2 = v0 - v2;
        vec3 vp2 = P -v2;
        C = edge2 * vp2;
        if(dot(N, C) < 0.0) return veryBigNum;

        return t;
    }

    const float sphereShininess = 20.0;
    const float planeShininess = 1e10;

    bool checkIntersect(Ray ray, out float minT, out vec3 surfacePoint, out vec3 surfaceNormal,
    out vec3 cameraSource, out vec3 cameraDirection, out vec3 objColor, out float shininess) {
        float t = 0.0;
        float sphereMinT = veryBigNum;
        float planeMinT = veryBigNum;
        minT =  veryBigNum;

        Sphere sphereToShow;
        TrianglePlane planeToShow;

        cameraSource = ray.origin;
        cameraDirection = ray.direction;

        // check sphere intersection
        for(int i = 0; i < sphereNum; i++) {
            t = checkIntersectSphere(spheres[i], ray);

            if (t > 0.0 && t < minT) {
                sphereMinT = t;
                sphereToShow = spheres[i];
            }
        }
        //check plane intersection
        for(int i = 0; i < planeNum; i++) {
            t = checkIntersectTPlane(tPlanes[i], ray);

            if (t > 0.0 && t < minT) {
                planeMinT = t;
                planeToShow = tPlanes[i];
            }
        }

        if(sphereMinT < planeMinT) { // if the closest interect is a sphere
            minT = sphereMinT;
            if(minT > 0.0 && minT < veryBigNum) {
                vec3 sphereCenter = sphereToShow.center;

                objColor = sphereToShow.color;
                surfacePoint = cameraSource + (minT * cameraDirection);
                surfaceNormal = normalize(surfacePoint - sphereCenter);
                shininess = sphereShininess;

                return true;
            }
        }
        else {  // if the closest interect is a plane
            minT = planeMinT;
            if(minT > 0.0 && minT < veryBigNum) {
                objColor = planeToShow.color;
                surfacePoint = cameraSource + (minT * cameraDirection);
                surfaceNormal = -newell(planeToShow.v1, planeToShow.v2, planeToShow.v3);
                shininess = planeShininess;
                return true;
            }
        }

        return false;
    }

    bool checkIntersectShadow(Ray ray) {
        float minT;

        float t = 0.0;
        float sphereMinT = veryBigNum;
        float planeMinT = veryBigNum;
        minT =  veryBigNum;

        // check sphere intersection
        for(int i = 0; i < sphereNum; i++) {
            t = checkIntersectSphere(spheres[i], ray);

            if (t > 0.0 && t < minT) {
                sphereMinT = t;
            }
        }
        //check plane intersection
        for(int i = 0; i < planeNum; i++) {
            t = checkIntersectTPlane(tPlanes[i], ray);

            if (t > 0.0 && t < minT) {
                planeMinT = t;
            }
        }

        if (planeMinT < veryBigNum || sphereMinT < veryBigNum) {
            return true;
        }
        else return false;
    }

    vec3 getRay(Ray ray, Light light) {
         RayTracerOutput rayTracer;

         vec3 lightSource = light.position;
         float ambience = light.ambience;

         vec3 objColor;
         float minT;
         vec3 surfacePoint;
         vec3 surfaceNormal;
         vec3 cameraSource;
         vec3 cameraDirection;
         float shininess;

         float veryBigNum = 1e38;

         Ray reflectionRay;
         Ray curRay = ray;
         vec3 accumColor = vec3(0.0);

        const int numBounces = 100;

         for (int i = 0; i < numBounces; i ++) {
             if (i > bounceNum-1) break;

             if(checkIntersect(curRay, minT, surfacePoint, surfaceNormal, cameraSource, cameraDirection, objColor, shininess)) {

                 // deal with reflection
                 vec3 reflectionDir = normalize(2.0 * dot(-ray.direction, surfaceNormal) * surfaceNormal + ray.direction); // this is the reflection vector
                 reflectionRay.origin = surfacePoint + 0.0001 * reflectionDir;  // avoid z fighting
                 reflectionRay.direction = reflectionDir;

                 vec3 lightDirection = normalize(lightSource  - surfacePoint);

                 Ray toLightRay;
                 toLightRay.origin = reflectionRay.origin;
                 toLightRay.direction = lightDirection;

                 // check if the point is in shadow
                 if(checkIntersectShadow(toLightRay)) {
                     accumColor = accumColor + objColor * ambience;
                 }
                 else {
                     float specular = pow(max(dot(reflectionDir, lightDirection), 0.0), shininess);
                     float diffuse = max(0.0, dot(surfaceNormal, lightSource));
                     accumColor = accumColor + objColor * (ambience + (1.0 - ambience) * diffuse * pow(reflectDecay, float(i)));
                     accumColor = accumColor + lightColor * specular;
                 }

             }
             else {  // the ray did not hit anything
                 accumColor = accumColor + vec3(0.0, 0.0, 0.0);
                 break;
             }

             // continue with the reflected ray
             curRay = reflectionRay;
         }
         return accumColor;
     }

    void main() {
        initialize();
        vec3 color = getRay(rays[0], light[0]);

        gl_FragColor = vec4(color, 1.0);
   }
</script>

    <script src="lib/webgl-utils.js"></script>
    <script src="lib/initShaders.js"></script>
    <script src="lib/MV.js"></script>

    <script src="main.js"></script>

</head>

<body onload="main()">

<canvas id="webgl" width="400" height="400">
    Please use a browser that supports the "canvas" tag.
</canvas>

</body>
</html>
