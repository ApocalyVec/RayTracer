<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Ray Tracer</title>

    <style>
        canvas {
            padding-left: 0;
            padding-right: 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 25px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            background: #4CAF50;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            background: #4CAF50;
            cursor: pointer;
        }
    </style>

<script id="vshader" type="x-shader/x-vertex">
   attribute vec3 aPosition;
   varying   vec3 vPosition;

   // user inputs
   uniform float sceneNum;
   varying float fsceneNum;

   uniform float vSphereShininess;
   varying float sphereShininess;

   uniform float vPlaneShininess;
   varying float planeShininess;

   uniform float vNumBounces;
   varying float bounceNum;

   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;

       fsceneNum = sceneNum;
       sphereShininess = vSphereShininess;
       planeShininess = vPlaneShininess;
       bounceNum = vNumBounces;
   }
</script>

<script id="fshader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec3 vPosition;

    varying float fsceneNum;

    varying float planeShininess;
    varying float sphereShininess;

    varying float bounceNum;

    struct Sphere {
        vec3 center;
        float radius;
        vec3 color;
    };

    struct Triangle {
        vec3 v1;
        vec3 v2;
        vec3 v3;
        vec3 normal;
        vec3 color;
    };

    struct Plane {
        vec3 normal;
        vec3 p;
        vec3 color;
        vec3 lightingNormal;
    };

    struct Ray {
        vec3 origin;
        vec3 direction;
    };

    struct Light {
        vec3 position;
        float radius;

        float ambience;
        vec3 specular;
        vec3 diffuse;
    };

    const int objNum = 10;

    Ray rays[1];
    Light light[objNum];

    Sphere spheres[objNum];
    Triangle triangles[objNum];
    Plane planes[objNum];

    float sphereAbsorbList[objNum];

    const float triangleAbsorb = 0.5;
    const float planeAbsorb = 1.0 - 1e-32;

    vec3 newell(vec3 v1, vec3 v2, vec3 v3) {
        float n1, n2, n3;

        n1 = (v1[1] - v2[1]) * (v1[2] + v2[2]) +
        (v2[1] - v3[1]) * (v2[2] + v3[2]) +
        (v3[1] - v1[1]) * (v3[2] + v1[2]);

        n2 = (v1[2] - v2[2]) * (v1[0] + v2[0]) +
        (v2[2] - v3[2]) * (v2[0] + v3[0]) +
        (v3[2] - v1[2]) * (v3[0] + v1[0]);

        n3 = (v1[0] - v2[0]) * (v1[1] + v2[1]) +
        (v2[0] - v3[0]) * (v2[1] + v3[1]) +
        (v3[0] - v1[0]) * (v3[1] + v1[1]);

        vec3 normal = normalize(vec3(n1, n2, n3));

        return normal;
    }

    void initialize() {
        float x = vPosition.x; // pixel positions x
        float y = vPosition.y; // pixel positions y
        float z = vPosition.z; // pixel positions z
        vec3 color = vec3(0.0, 0.0, 0.0);

        light[0].radius = 0.02;

        if (fsceneNum == 1.0) {
            float focalLength = 1.5;
            // aobsorb factor for the spheres when reflecting
            for (int i = 0; i < objNum; i ++) {
                sphereAbsorbList[i] = 0.5;
            }

            // Create spheres
            spheres[0].center = vec3(-.1, .2, 0);
            spheres[0].radius = 0.2;
            spheres[0].color = vec3(1.0, 0.0, 0.0);

            // create a second sphere
            spheres[1].center = vec3(.3, .2, -.4);
            spheres[1].radius = 0.2;
            spheres[1].color = vec3(0.0, 1.0, 0.0);

            // create Triangles
            triangles[0].v1 = vec3(2.0, -.6, 2.0);
            triangles[0].v2 = vec3(-2.0, -.6, 2.0);
            triangles[0].v3 = vec3(-2.0, -.6, -2.0);
            triangles[0].normal = -newell(triangles[0].v1, triangles[0].v2, triangles[0].v3);
            triangles[0].color = vec3(0.0, 0.0, 1.0);

            triangles[1].v1 = vec3(2.0, -.6, 2.0);
            triangles[1].v2 = vec3(-2.0, -.6, -2.0);
            triangles[1].v3 = vec3(2.0, -.6, -2.0);
            triangles[1].normal = -newell(triangles[1].v1, triangles[1].v2, triangles[1].v3);
            triangles[1].color = vec3(0.0, 0.0, 1.0);

            // Create ray
            rays[0].origin = vec3(.2, .3, focalLength);
            rays[0].direction = normalize(vec3(x, y, -focalLength));

            // Create Light source
            light[0].position = vec3(-2.0, 2.0, 2.0);
            light[0].ambience = 0.3;
        }
        else if (fsceneNum == 2.0) {
            // aobsorb factor for the spheres when reflecting
            for (int i = 0; i < objNum; i ++) {
                sphereAbsorbList[i] = 0.6;
            }

            float focalLength = 2.0;

            float spherePos = 0.3;
            float sphereRad = 0.25;

            // Create spheres
            spheres[0].center = vec3(-spherePos, -spherePos, 0.5);
            spheres[0].radius = sphereRad;
            spheres[0].color = vec3(1.0, 0.0, 0.0);

            // create a second sphere
            spheres[1].center = vec3(spherePos, spherePos, 0.5);
            spheres[1].radius = sphereRad;
            spheres[1].color = vec3(0.0, 1.0, 0.0);

            // create a third sphere
            spheres[2].center = vec3(-spherePos, spherePos, 0.5);
            spheres[2].radius = sphereRad;
            spheres[2].color = vec3(1.0, 1.0, 0.0);

            // the forth sphere
            spheres[3].center = vec3(spherePos, -spherePos, .5);
            spheres[3].radius = sphereRad;
            spheres[3].color = vec3(0.0, 0.0, 1.0);

            // Create ray
            rays[0].origin = vec3(.0, .0, focalLength);
            rays[0].direction = normalize(vec3(x, y, -focalLength));

            // Create Light source
            light[0].position = vec3(0.0, 0.0, 1.75);
            light[0].ambience = 0.2;

            light[0].radius = 0.001;

        }
        else if (fsceneNum == 3.0) {
            // aobsorb factor for the spheres when reflecting
            for (int i = 0; i < objNum; i ++) {
                sphereAbsorbList[i] = 1.0 - 1e-32;
            }
            sphereAbsorbList[0] = 0.001;  // the first sphere is completely reflective

            float focalLength = 2.0;

            // Create spheres
            spheres[0].center = vec3(-.4, -.4, 0.0);
            spheres[0].radius = 0.1;
            spheres[0].color = vec3(0.0, 0.0, 0.0);

            // create a second sphere
            spheres[1].center = vec3(.3, -.3, -0.2);
            spheres[1].radius = 0.2;
            spheres[1].color = vec3(1.0, 1.0, 1.0);

            // create plane
            // bottom plane
            planes[0].normal = normalize(vec3(0.0, 1.0, 0.0));
            planes[0].p = vec3(0.0, -0.5, 0.0);
            planes[0].color = vec3(0.0, 0.0, 1.0);
            planes[0].lightingNormal = vec3(0.0, 1.0, 1.0);

            //top plane
            planes[1].normal = normalize(vec3(0.0, -1.0, 0.0));
            planes[1].p = vec3(0.0, 0.4, 0.0);
            planes[1].color = vec3(1.0, 1.0, 0.0);
            planes[1].lightingNormal = vec3(0.0, 1.0, 1.0);

            // back plane
            planes[2].normal = normalize(vec3(0.0, 0.0, 1.0));
            planes[2].p = vec3(0.0, 0.0, -0.5);
            planes[2].color = vec3(0.0, 1.0, 1.0);
            planes[2].lightingNormal = vec3(0.0, 1.0, 1.0);

            //front plane
            planes[3].normal = normalize(vec3(0.0, 0.0, -1.0));
            planes[3].p = vec3(0.0, 0.0, 0.5);
            planes[3].color = vec3(1.0, 1.0, 1.0);
            planes[3].lightingNormal = vec3(0.0, 1.0, 1.0);

            //right plane
            planes[4].normal = normalize(vec3(-1.0, 0.0, 0.1));
            planes[4].p = vec3(.5, 0.0, 0.0);
            planes[4].color = vec3(1.0, 0.0, 0.0);
            planes[4].lightingNormal = vec3(0.0, 1.0, 1.0);

            //left plane
            planes[5].normal = normalize(vec3(1.0, 0.0, 0.1));
            planes[5].p = vec3(-.5, 0.0, 0.0);
            planes[5].color = vec3(1.0, 0.0, 1.0);
            planes[5].lightingNormal = vec3(0.0, 1.0, 1.0);

            // Create ray
            rays[0].origin = vec3(.0, .0, focalLength);
            rays[0].direction = normalize(vec3(x, y, -focalLength));

            // Create Light source
            light[0].position = vec3(0.0, .4, 0.4);
            light[0].ambience = 0.3;
        }
    }

    const float veryBigNum = 1e23;
    const float verySmallNum = 1e-23;

    const float lightShininess = verySmallNum;

    vec3 lightColor = vec3(1.0);

    bool checkIntersectSphere(Sphere sphere, Ray ray, out float t) {
        t = veryBigNum;

        vec3 sphereCenter = sphere.center;
        float radius = sphere.radius;
        vec3 cameraSource = ray.origin;
        vec3 cameraDirection = ray.direction;

        vec3 distanceFromCenter = (cameraSource - sphereCenter);
        float B = 2.0 * dot(cameraDirection, distanceFromCenter);
        float C = dot(distanceFromCenter, distanceFromCenter) - pow(radius, 2.0);
        float delta = pow(B, 2.0) - 4.0 * C;
        if (delta > 0.0) {
            float sqRoot = sqrt(delta);
            float t1 = (-B + sqRoot) / 2.0;
            float t2 = (-B - sqRoot) / 2.0;
            t = min(t1, t2);
        }
        if (delta == 0.0) {
            t = -B / 2.0;
        }

        if (t > 0.0 && t < veryBigNum) {
            return true;
        }
        else {
            return false;
        }
    }

    bool checkIntersectLight(Light light, Ray ray, out float t) {
        t = veryBigNum;

        vec3 sphereCenter = light.position;
        float radius = light.radius;
        vec3 cameraSource = ray.origin;
        vec3 cameraDirection = ray.direction;

        vec3 distanceFromCenter = (cameraSource - sphereCenter);
        float B = 2.0 * dot(cameraDirection, distanceFromCenter);
        float C = dot(distanceFromCenter, distanceFromCenter) - pow(radius, 2.0);
        float delta = pow(B, 2.0) - 4.0 * C;
        if (delta > 0.0) {
            float sqRoot = sqrt(delta);
            float t1 = (-B + sqRoot) / 2.0;
            float t2 = (-B - sqRoot) / 2.0;
            t = min(t1, t2);
        }
        if (delta == 0.0) {
            t = -B / 2.0;
        }

        if (t > 0.0 && t < veryBigNum) {
            return true;
        }
        else {
            return false;
        }
    }

    bool checkIntersectPlane(Plane plane, Ray ray, out float t) {

        vec3 n = -plane.normal;
        vec3 l = ray.direction;
        vec3 l0 = ray.origin;
        vec3 p0 = plane.p;

        float denom = dot(n, l);
        if (denom > 1e-6) {
            vec3 p0l0 = p0 - l0;
            t = dot(p0l0, n) / denom;
            return (t >= 0.0);
        }

        return false;
    }

    // adopted from
    // https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/ray-triangle-intersection-geometric-solution
    bool checkIntersectTriangle(Triangle triangle, Ray ray, out float t) {

        vec3 v0 = triangle.v1;
        vec3 v1 = triangle.v2;
        vec3 v2 = triangle.v3;

        vec3 orig = ray.origin;
        vec3 dir = ray.direction;

        // compute the pane's normal
        vec3 v0v1 = v1 - v0;
        vec3 v0v2 = v2 - v0;
        // no need to normalize
        vec3 N = cross(v0v1, v0v2);

        // check if the ray and the plane are parallel
        float NdotRayDirection = dot(N, dir);
        if(abs(NdotRayDirection) < verySmallNum) return false;  // the ray and the plane does not intersect because they are parallel

        // compute d
        float d = dot(N, v0); // distance from the origin to the plane
        //compute t
        t = (dot(N, orig) + d) / NdotRayDirection;

        //check if the triangle is behind the ray
        if (t < 0.0) return false;  // the triangle is behind

        //compute the intersection point
        vec3 P = orig + t * dir;

        vec3 C; // vector perpendicular to triangle's plane

        // edge 0
        vec3 edge0 = v1 - v0;
        vec3 vp0 = P - v0;
        C = cross(edge0, vp0);
        if (dot(C, N) < 0.0) return false; // P is on the right side

        // edge 1
        vec3 edge1 = v2 - v1;
        vec3 vp1 = P - v1;
        C = cross(edge1, vp1);
        if (dot(C, N) < 0.0)  return false; // P is on the right side

        // edge 2
        vec3 edge2 = v0 - v2;
        vec3 vp2 = P - v2;
        C = cross(edge2, vp2);
        if (dot(C, N) < 0.0) return false; // P is on the right side;

        return true;
    }

    bool checkIntersect(Ray ray, out float minT, out vec3 surfacePoint, out vec3 surfaceNormal, out vec3 lightingNormal,
    out vec3 cameraSource, out vec3 cameraDirection, out vec3 objColor, out float shininess, out float absorb, out bool isLightSource) {
        float t;
        float sphereMinT = veryBigNum;
        float triangleMinT = veryBigNum;
        float planeMinT = veryBigNum;
        float lightMinT = veryBigNum;

        float sphereAbsorb;

        minT =  veryBigNum;

        Sphere sphereToShow;
        Triangle triangleToShow;
        Plane planeToShow;
        Light lightToShow;

        cameraSource = ray.origin;
        cameraDirection = ray.direction;

        // check sphere intersection
        for(int i = 0; i < objNum; i++) {
            if (checkIntersectSphere(spheres[i], ray, t)) {
                if (t < sphereMinT) {
                    sphereMinT = t;
                    sphereToShow = spheres[i];
                    sphereAbsorb = sphereAbsorbList[i];
                }
            }
        }
        //check triangle intersection
        for(int i = 0; i < objNum; i++) {
            if (checkIntersectTriangle(triangles[i], ray, t)) {
                if(t < triangleMinT) {
                    triangleMinT = t;
                    triangleToShow = triangles[i];
                }
            }
        }

        // check plane intersection
        for(int i = 0; i < objNum; i ++) {
            if (checkIntersectPlane(planes[i], ray, t)) {
                if (t < planeMinT) {
                    planeMinT = t;
                    planeToShow = planes[i];
                }
            }
        }

        // check light source intersection
        for(int i = 0; i < objNum; i++) {
            if (checkIntersectLight(light[i], ray, t)) {
                if (t < sphereMinT) {
                    lightMinT = t;
                    lightToShow = light[i];
                }
            }
        }

        isLightSource = false;

        if(min(lightMinT, min(planeMinT, min(sphereMinT, triangleMinT))) == sphereMinT && sphereMinT < veryBigNum) { // if the closest interect is a sphere
            minT = sphereMinT;
            // sphere absorb is already processed in 'check sphere intersection'
            absorb = sphereAbsorb;

            vec3 sphereCenter = sphereToShow.center;
            objColor = sphereToShow.color;
            surfacePoint = cameraSource + (minT * cameraDirection);
            surfaceNormal = lightingNormal = normalize(surfacePoint - sphereCenter);
            shininess = sphereShininess;
            return true;
        }
        else if (min(lightMinT, min(planeMinT, min(sphereMinT, triangleMinT))) == triangleMinT && triangleMinT < veryBigNum){  // if the closest interect is a triangle
            minT = triangleMinT;
            absorb = triangleAbsorb;

            objColor = triangleToShow.color;
            surfacePoint = cameraSource + (minT * cameraDirection);
            surfaceNormal = lightingNormal = normalize(triangleToShow.normal);
            shininess = planeShininess;
            return true;
        }

        else if (min(lightMinT, min(planeMinT, min(sphereMinT, triangleMinT))) == planeMinT && planeMinT < veryBigNum){  // if the closest interect is a plane
            minT = planeMinT;
            absorb = planeAbsorb;

            objColor = planeToShow.color;
            surfacePoint = cameraSource + (minT * cameraDirection);
            surfaceNormal = planeToShow.normal;
            lightingNormal = planeToShow.lightingNormal;
            shininess = planeShininess;
            return true;
        }
        else if (min(lightMinT, min(planeMinT, min(sphereMinT, triangleMinT))) == lightMinT && lightMinT < veryBigNum){  // if the closest interect is a plane
            minT = lightMinT;
            isLightSource = true;
            objColor = vec3(1.0, 1.0, 1.0);  // light is white

            return true;
        }

            return false;
    }

    bool checkIntersectShadow(Ray ray, out float shadow_det) {

        float t = 0.0;
        float minT = veryBigNum;
        float sphereMinT = veryBigNum;
        float triangleMinT = veryBigNum;
        float planeMinT = veryBigNum;
        float lightMinT = veryBigNum;

        bool isIntersect = false;

        // check sphere intersection
//        for(int i = 0; i < objNum; i++) {
//            isIntersect = isIntersect || (checkIntersectSphere(spheres[i], ray, t));
//        }
//        //check triangle intersection
//        for(int i = 0; i < objNum; i++) {
//            isIntersect = isIntersect || ( checkIntersectTriangle(triangles[i], ray, t));
//        }

        // check sphere intersection
        for(int i = 0; i < objNum; i++) {
            if (checkIntersectSphere(spheres[i], ray, t)) {
                if (t < sphereMinT) {
                    sphereMinT = t;
                }
            }
        }
        //check triangle intersection
        for(int i = 0; i < objNum; i++) {
            if (checkIntersectTriangle(triangles[i], ray, t)) {
                if(t < triangleMinT) {
                    triangleMinT = t;
                }
            }
        }

        // check plane intersection
        for(int i = 0; i < objNum; i ++) {
            if (checkIntersectPlane(planes[i], ray, t)) {
                if (t < planeMinT) {
                    planeMinT = t;
                }
            }
        }

        // check light source intersection
        for(int i = 0; i < objNum; i++) {
            if (checkIntersectLight(light[i], ray, t)) {
                if (t < sphereMinT) {
                    lightMinT = t;
                }
            }
        }

        return !(min(lightMinT, min(planeMinT, min(sphereMinT, triangleMinT))) == lightMinT);
    }

    vec3 getRay(Ray ray, Light light) {

         vec3 lightSource = light.position;
         float ambience = light.ambience;

         vec3 objColor;
         float minT;
         vec3 surfacePoint;
         vec3 surfaceNormal;
        vec3 lightingNormal;
         vec3 cameraSource;
         vec3 cameraDirection;
         float shininess;
         float absorb;

        bool isLightSource;

         float veryBigNum = 1e38;

         Ray reflectionRay;
         vec3 accumColor = vec3(0.0);

        const int numBounces = 100;

        float shadow_det;

         for (int i = 0; i < numBounces; i ++) {
             if (i >= int(bounceNum)) break;  // if the number of reflection is reached

             if(checkIntersect(ray, minT, surfacePoint, surfaceNormal, lightingNormal, cameraSource, cameraDirection, objColor, shininess, absorb, isLightSource)) {
                 if(isLightSource) {
                    return lightColor;
                 }
                 // deal with reflection
                 vec3 reflectionDir =reflect(ray.direction, surfaceNormal); // this is the reflection vector
                 reflectionRay.origin = surfacePoint + 0.00001 * reflectionDir;  // avoid z fighting

//                 vec3 reflectionDir =refract(ray.direction, surfaceNormal, 0.98); // this is the reflection vector
//                 reflectionRay.origin = surfacePoint - 0.00001 * reflectionDir;  // avoid z fighting

                 reflectionRay.direction = reflectionDir;

                 vec3 lightDirection = normalize(lightSource  - surfacePoint);

                 Ray toLightRay;
                 toLightRay.origin = reflectionRay.origin;
                 toLightRay.direction = lightDirection;

                 // check if the point is in shadow
                 if(checkIntersectShadow(toLightRay, shadow_det)) {
                     accumColor = accumColor + objColor * ambience;
                 }
                 else {
                     float specular = pow(max(dot(reflectionDir, lightDirection), 0.0), shininess);
                     float diffuse = max(0.0, dot(lightingNormal, lightSource));

                     // ternary: light is absorb by the object after reflection
                     accumColor = accumColor + objColor * (ambience + (1.0 - ambience) * diffuse)*(i > 1 ? absorb : 1.0);
                     accumColor = accumColor + lightColor * specular * (absorb)*(i > 1 ? absorb : 1.0);
                 }
             }

              else {  // the ray did not hit anything
                  break;
              }

             if((1.0 - absorb) < verySmallNum) {
                 break;
             }
             // continue with the reflected ray
             ray = reflectionRay;
         }

         return accumColor;
     }

    void main() {
        initialize();
        vec3 color = getRay(rays[0], light[0]);

        gl_FragColor = vec4(color, 1.0);
   }
</script>

    <script src="lib/webgl-utils.js"></script>
    <script src="lib/initShaders.js"></script>
    <script src="lib/MV.js"></script>

    <script src="main.js"></script>

</head>

<body onload="main()">

<canvas id="webgl" width="1000" height="1000" >
    Please use a browser that supports the "canvas" tag.
</canvas>
<div style="text-align: center; margin: 30px">
    <h1>
        <span style="font-weight:bold">Use number key 1~3 to switch between scenes.</span>
    </h1>
</div>

<div id = "sliderContainer">

    <input type="range" min="1.0" max="100.0" value="20.0" class="slider" id="sphereShininessSlider" name="sphereShininessSlider">
    <label for="sphereShininessSlider">Slide to Change Sphere Shininess</label>

    <input type="range" min="1.0" max="100.0" value="10.0" class="slider" id="planeShininessSlider" name="planeShininessSlider">
    <label for="planeShininessSlider">Slide to Change Plane Shininess</label>

    <input type="range" min="1" max="6" value="4.0" class="slider" id="numBouncesSlider" name="numBouncesSlider">
    <label for="numBouncesSlider">Slide to Number of Reflections</label>

</div>


</body>
</html>
